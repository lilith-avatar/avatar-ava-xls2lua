#! /usr/bin/env python
# -*- coding: utf-8 -*
# author: luzexi

import xlrd
import os.path
import time
import os
import sys
import codecs

INPUT_FOLDER = './xls'
OUTPUT_FOLDER = './luatable'
OUTPUT_LUA_TEMPLATE = "['World']['Global']['LuaTable']['{sheet_name}CSV'].ModuleScript.lua"

INFO = '[\033[36minfo\033[0m] '
ERROR = '[\033[31merror\033[0m] '
SUCCESS = '[\033[92msucess\033[0m] '
FAILED = '[\033[91mfailed\033[0m] '


SCRIPT_HEAD = '''--- This file is generated by ava-xls2lua.py,
--- Don't change it manaully.\
--- @copyright Lilith Games, Project Da Vinci(Avatar Team)
--- @see https://www.projectdavinci.com/
--- source file: %s

'''


def make_table(filename):
    if not os.path.isfile(filename):
        raise NameError('%s is	not	a valid	filename' % filename)
    book_xlrd = xlrd.open_workbook(filename, formatting_info=True)
    # book_xlrd = xlrd.open_workbook(filename)

    excel = {}
    excel = {}
    excel['filename'] = filename
    excel['data'] = {}
    excel['meta'] = {}

    for sheet in book_xlrd.sheets():
        sheet_name = sheet.name.replace(' ', '_')
        if not sheet_name.startswith('output_'):
            continue
        sheet_name = sheet_name[7:]
        # print(sheet_name +' sheet')
        excel['data'][sheet_name] = {}
        excel['meta'][sheet_name] = {}

        # 必须大于2行
        if sheet.nrows <= 2:
            return {}, -1, 'sheet[' + sheet_name + ']' + ' rows must > 2'

        # 解析标题
        title = {}
        col_idx = 0
        for col_idx in range(sheet.ncols):
            value = sheet.cell_value(0, col_idx)
            vtype = sheet.cell_type(0, col_idx)
            if vtype != 1:
                return {}, -1, 'title columns[' + str(col_idx) + '] must be string'
            title[col_idx] = str(value).replace(' ', '_')

        excel['meta'][sheet_name]['title'] = title

        # 类型解析
        type_dict = {}
        col_idx = 0
        for col_idx in range(sheet.ncols):
            value = sheet.cell_value(1, col_idx)
            vtype = sheet.cell_type(1, col_idx)
            type_dict[col_idx] = str(value)
            if (type_dict[col_idx].lower() != 'i'
                    and type_dict[col_idx].lower() != 'f'
                    and type_dict[col_idx].lower() != 's'
                    and type_dict[col_idx].lower() != 'b'
                    and type_dict[col_idx].lower() != 'ai'
                    and type_dict[col_idx].lower() != 'af'
                    and type_dict[col_idx].lower() != 'as'
                    and type_dict[col_idx].lower() != 'ab'):
                return {}, -1, 'sheet[' + sheet_name + ']' + \
                    ' row[' + row_idx + '] column[' + col_idx + \
                    '] type must be [i] or [s] or [b] or [ai] or [as] or [ab]'

        if type_dict[0].lower() != 'i':
            return {}, -1, 'sheet[' + sheet_name + ']' + ' first column type must be [i]'

        excel['meta'][sheet_name]['type'] = type_dict

        row_idx = 2
        # 数据从第3行开始
        for row_idx in range(2, sheet.nrows):
            row = {}

            col_idx = 0
            for col_idx in range(sheet.ncols):
                value = sheet.cell_value(row_idx, col_idx)
                vtype = sheet.cell_type(row_idx, col_idx)
                # 本行有数据
                v = None
                if type_dict[col_idx].lower() == 'i' and vtype == 2:
                    v = int(value)
                elif type_dict[col_idx].lower() == 'f' and vtype == 2:
                    v = float(value)
                elif type_dict[col_idx].lower() == 's':
                    v = format_str(value)
                elif type_dict[col_idx].lower() == 'b' and vtype == 4:
                    if value == 1:
                        v = 'true'
                    else:
                        v = 'false'
                elif type_dict[col_idx].lower() == 'ai' and vtype == 1:
                    v = str(value)
                elif type_dict[col_idx].lower() == 'af' and vtype == 1:
                    v = str(value)
                elif type_dict[col_idx].lower() == 'as':
                    v = format_str(value)
                elif type_dict[col_idx].lower() == 'ab' and vtype == 1:
                    v = str(value)

                row[col_idx] = v

            excel['data'][sheet_name][row[0]] = row

    return excel, 0, 'ok'


def format_str(v):
    if type(v) == int or type(v) == float:
        v = str(v)
    s = v
    s = v.replace('\"', '\\\"')
    s = s.replace('\'', '\\\'')
    return s


def get_i(v):
    if v is None:
        return 0
    return v


def get_f(v):
    if v is None:
        return 0
    return v


def get_s(v):
    if v is None:
        return ''
    return v


def get_b(v):
    if v is None:
        return 'false'
    return v


def get_ai(v):
    if v is None:
        return '{}'
    tmp_vec_str = v.split(';')
    res_str = '{'
    i = 0
    for val in tmp_vec_str:
        if val != None and val != '':
            if i != 0:
                res_str += ','
            res_str = res_str + val
            i += 1
    res_str += '}'
    return res_str


def get_af(v):
    if v is None:
        return '{}'
    tmp_vec_str = v.split(';')
    res_str = '{'
    i = 0
    for val in tmp_vec_str:
        if val != None and val != '':
            if i != 0:
                res_str += ','
            res_str = res_str + val
            i += 1
    res_str += '}'
    return res_str


def get_as(v):
    if v is None:
        return '{}'
    tmp_vec_str = v.split(';')
    res_str = '{'
    i = 0
    for val in tmp_vec_str:
        if val != None and val != '':
            if i != 0:
                res_str += ','
            res_str = res_str + '\'' + val + '\''
            i += 1
    res_str += '}'
    return res_str


def get_ab(v):
    if v is None:
        return '{}'
    tmp_vec_str = v.split(';')
    res_str = '{'
    i = 0
    for val in tmp_vec_str:
        if val != None and val != '':
            if i != 0:
                res_str += ','
            res_str = res_str + val.lower()
            i += 1
    res_str += '}'
    return res_str


def write_to_lua_script(excel, output_path):
    for (sheet_name, sheet) in excel['data'].items():
        file_name = OUTPUT_LUA_TEMPLATE.format(sheet_name=sheet_name)
        outfp = codecs.open(output_path + '/' + file_name, 'w', "utf-8")
        outfp.write(SCRIPT_HEAD % (excel['filename']))
        outfp.write('local ' + sheet_name + ' = {\n')
        title = excel['meta'][sheet_name]['title']
        type_dict = excel['meta'][sheet_name]['type']

        for (row_idx, row) in sheet.items():
            outfp.write('    [' + str(row_idx) + '] = {\n')
            for (col_idx, field) in row.items():
                if type_dict[col_idx] == 'i':
                    tmp_str = get_i(row[col_idx])
                    outfp.write(
                        '        ' + str(title[col_idx]) + ' = ' + str(tmp_str))
                elif type_dict[col_idx] == 'f':
                    tmp_str = get_f(row[col_idx])
                    outfp.write(
                        '        ' + str(title[col_idx]) + ' = ' + str(tmp_str))
                elif type_dict[col_idx] == 's':
                    tmp_str = get_s(row[col_idx])
                    outfp.write(
                        '        ' + str(title[col_idx]) + ' = \'' + str(tmp_str) + '\'')
                elif type_dict[col_idx] == 'b':
                    tmp_str = get_b(row[col_idx])
                    outfp.write(
                        '        ' + str(title[col_idx]) + ' = ' + str(tmp_str))
                elif type_dict[col_idx] == 'ai':
                    tmp_str = get_ai(row[col_idx])
                    outfp.write(
                        '        ' + str(title[col_idx]) + ' = ' + str(tmp_str))
                elif type_dict[col_idx] == 'af':
                    tmp_str = get_af(row[col_idx])
                    outfp.write(
                        '        ' + str(title[col_idx]) + ' = ' + str(tmp_str))
                elif type_dict[col_idx] == 'as':
                    tmp_str = get_as(row[col_idx])
                    outfp.write(
                        '        ' + str(title[col_idx]) + ' = ' + str(tmp_str))
                elif type_dict[col_idx] == 'ab':
                    tmp_str = get_ab(row[col_idx])
                    outfp.write(
                        '        ' + str(title[col_idx]) + ' = ' + str(tmp_str))
                else:
                    outfp.close()
                    raise RuntimeError('there is some wrong in type.')

                if col_idx == len(row.items()) - 1:
                    outfp.write('\n')
                else:
                    outfp.write(',\n')

            if row_idx == len(sheet.items()):
                outfp.write('    }\n')
            else:
                outfp.write('    },\n')
        outfp.write('}\n\nreturn ' + sheet_name + '\n')
        outfp.close()


def main():
    input_path = INPUT_FOLDER
    output_path = OUTPUT_FOLDER
    print(INFO + 'input path: \t{}'.format(input_path))
    print(INFO + 'output path: \t{}'.format(output_path))
    if not os.path.exists(input_path):
        raise RuntimeError('input path does NOT exist.')
    if not os.path.exists(output_path):
        os.mkdir(output_path)
        print(INFO + 'make a new dir: \t{}'.format(output_path))

    xls_files = os.listdir(input_path)
    if len(xls_files) == 0:
        raise RuntimeError('input dir is empty.')

    for xls_file in xls_files:
        lua_file = xls_file.replace('.xls', '.lua')
        t, ret, errstr = make_table(INPUT_FOLDER + '/' + xls_file)
        if ret != 0:
            print(FAILED + '{} => {}'.format(xls_file, lua_file))
            raise RuntimeError(errstr)
        else:
            # TODO 改成lua名字
            write_to_lua_script(t, output_path)
            print(SUCCESS + '{} => {}'.format(xls_file, lua_file))


if __name__ == '__main__':
    try:
        main()
        print(INFO + 'done.')
        print(INFO + 'press Enter to exit...')
    except RuntimeError as err:
        print(ERROR + str(err))
        print(INFO + 'check error please...')
